import MacroTools: @capture, postwalk, splitdef, splitarg # NOTE: inexpr_walk used instead of MacroTools.inexpr
import .ParallelKernel: eval_arg, split_args, split_kwargs, extract_posargs_init, extract_kernel_args, insert_device_types, is_kernel, is_call, gensym_world, isgpu, iscpu, @isgpu, @iscpu, substitute, substitute_in_kernel, in_signature, inexpr_walk, adjust_signatures, handle_indices_and_literals, add_inbounds, cast, @ranges, @rangelengths, @return_value, @return_nothing, @firstindex, @lastindex, is_access, find_vars, handle_padding, handle_inverses, increment_arg
import .ParallelKernel: PKG_CUDA, PKG_AMDGPU, PKG_METAL, PKG_THREADS, PKG_POLYESTER, PKG_NONE, NUMBERTYPE_NONE, SUPPORTED_NUMBERTYPES, SUPPORTED_PACKAGES, ERRMSG_UNSUPPORTED_PACKAGE, INT_CUDA, INT_AMDGPU, INT_METAL, INT_POLYESTER, INT_THREADS, INDICES, INDICES_INN, INDICES_DIR, INDICES_DIR_FUNCTIONS_SYMS, PKNumber, RANGES_VARNAME, RANGES_TYPE, RANGELENGTH_XYZ_TYPE, RANGELENGTHS_VARNAMES, THREADIDS_VARNAMES, GENSYM_SEPARATOR, AD_SUPPORTED_ANNOTATIONS, ARRAYTYPES, FIELDTYPES, SCALARTYPES
import .ParallelKernel: @require, @symbols, symbols, longnameof, @prettyexpand, @prettystring, prettystring, @gorgeousexpand, @gorgeousstring, gorgeousstring, interpolate


## CONSTANTS

const WITHIN_DOC = """
    @within(macroname::String, A)

Return an expression that evaluates to `true` if the indices generated by @parallel (module ParallelStencil) point to elements in bounds of the selection of `A` by `macroname`.

!!! warning
    This macro is not intended for explicit manual usage. Calls to it are automatically added by @parallel where required.
"""

const SUPPORTED_NDIMS                = [1, 2, 3]
const NDIMS_NONE                     = 0
const ERRMSG_KERNEL_UNSUPPORTED      = "unsupported kernel statements in @parallel kernel definition: @parallel is only applicable to kernels that contain exclusively array assignments using macros from FiniteDifferences{1|2|3}D or from another compatible computation submodule. @parallel_indices supports any kind of statements in the kernels."
const ERRMSG_CHECK_NDIMS             = "ndims must be evaluatable at parse time (e.g. literal or constant) and has to be one of the following Integers: $(join(SUPPORTED_NDIMS,", "))"
const ERRMSG_CHECK_MEMOPT            = "memopt must be evaluatable at parse time (e.g. literal or constant) and has to be of type Bool."
const ERRMSG_CHECK_NONCONST_METADATA = "nonconst_metadata must be evaluatable at parse time (e.g. literal or constant) and has to be of type Bool."
const PSNumber                       = PKNumber
const LOOPSIZE                       = 16
const LOOPDIM_NONE                   = 0
const NTHREADS_MAX_MEMOPT_CUDA       = 128
const NTHREADS_MAX_MEMOPT_AMDGPU     = 256
const NTHREADS_MAX_MEMOPT_METAL      = 256
const USE_SHMEMHALO_DEFAULT          = true
const USE_SHMEMHALO_1D_DEFAULT       = true
const USE_FULLRANGE_DEFAULT          = (false, false, true)
const FULLRANGE_THRESHOLD            = 1
const NOEXPR                         = :(begin end)
const MOD_METADATA                   = :__metadata__ # gensym_world("__metadata__", @__MODULE__) # # TODO: name mangling should be used here later, or if there is any sense to leave it like that then at check whether it's available must be done before creating it
const META_FUNCTION_PREFIX           = string(gensym_world("META", @__MODULE__))


## FUNCTIONS TO DEAL WITH KERNEL DEFINITIONS

get_statements(body::Expr)        = (body.head == :block) ? body.args : [body]
is_array_assignment(statement)    = isa(statement, Expr) && (statement.head == :(=)) && isa(statement.args[1], Expr) && (statement.args[1].head == :macrocall)
is_stencil_access(ex, indices...) = is_access(ex, indices...)

function is_stencil_access(ex::Expr, indices::NTuple{N,<:Union{Symbol,Expr}}, indices_dir::NTuple{N,<:Union{Symbol,Expr}}) where N
    is_access(ex, indices, indices_dir)
end

function validate_body(body::Expr)
    statements = get_statements(body)
    for statement in statements
        if !(isa(statement, LineNumberNode) || isa(statement, Expr)) @ArgumentError(ERRMSG_KERNEL_UNSUPPORTED) end
        if isa(statement, Expr) && !is_array_assignment(statement)   @ArgumentError(ERRMSG_KERNEL_UNSUPPORTED) end
    end
end

function substitute(expr::Union{Symbol,Expr}, A, m, indices::NTuple{N,<:Union{Symbol,Expr}} where N, indices_dir::NTuple{N,<:Union{Symbol,Expr}} where N)
    return postwalk(expr) do ex
        if is_stencil_access(ex, indices, indices_dir)
            @capture(ex, B_[indices_expr__]) || @ModuleInternalError("a stencil access could not be pattern matched.")
            if B == A
                m_call = :(@f($(indices_expr...))) # NOTE: interpolating the macro symbol m directly does not work
                m_call.args[1] = Symbol("@$m")
                return m_call
            else
                return ex
            end
        else
            return ex
        end
    end
end


## FUNCTIONS AND MACROS FOR USAGE IN CUSTOM MACRO DEFINITIONS

macro expandargs(args...) esc(quote $(args...), = ParallelStencil.expandargs(__module__, $(args...)) end) end

function expandargs(caller, args...; valid_types::NTuple{N,Type}=(Symbol, Expr)) where N
    for arg in args
        if (typeof(arg) âˆ‰ valid_types) @ArgumentError("argument $arg is not of type $(join(valid_types, ", ", " or ")).") end
    end
    args = macroexpand.((caller,), args)
    return args
end


## FUNCTIONS FOR ERROR HANDLING

check_ndims(ndims)                         = ( if !isa(ndims, Integer) || !(ndims in SUPPORTED_NDIMS) @ArgumentError("$ERRMSG_CHECK_NDIMS (obtained: $ndims)." ) end )
check_memopt(memopt)                       = ( if !isa(memopt, Bool) @ArgumentError("$ERRMSG_CHECK_MEMOPT (obtained: $memopt)." ) end )
check_nonconst_metadata(nonconst_metadata) = ( if !isa(nonconst_metadata, Bool) @ArgumentError("$ERRMSG_CHECK_NONCONST_METADATA (obtained: $nonconst_metadata)." ) end )